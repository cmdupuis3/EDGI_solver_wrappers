#ifndef EDGI_PLASMA_CPP
#define EDGI_PLASMA_CPP

#include <cstdlib>
#include <cassert>
#include <ctime>
#include <iostream>
#include <complex>
#include <string>
#include <omp.h>

#include "plasma.h"

using std::clock;
using std::complex;
using std::conj;
using std::cout;
using std::endl;
using std::rand;
using std::srand;



typedef enum svd_mat_type {
    SVD_MAT_GENERAL,
    SVD_MAT_SYMMETRIC,
    SVD_MAT_HERMITIAN
} svd_mat_t;


//==========================================================================
// Create solver results struct that can correctly match the results types
// to the kind of matrix we're solving. Ugly code alert!
//==========================================================================


// What types should the results be if the matrix is real-valued?
template<typename VTYPE, svd_mat_t SVD_TYPE> struct edgi_svd_results_t {
    VTYPE* U;
    VTYPE* S;
    VTYPE* VT;
    VTYPE* V;
};

// What types should the results be if the matrix is complex-valued, and the matrix is Hermitian?
template<typename VTYPE> struct edgi_svd_results_t<complex<VTYPE>, SVD_MAT_SYMMETRIC> {
    complex<VTYPE>* U;
    VTYPE* S;
    complex<VTYPE>* VT;
    complex<VTYPE>* V;
};
template<typename VTYPE> struct edgi_svd_results_t<complex<VTYPE>, SVD_MAT_HERMITIAN> {
    complex<VTYPE>* U;
    VTYPE* S;
    complex<VTYPE>* VT;
    complex<VTYPE>* V;
};

// What types should the results be if the matrix is complex-valued, and the matrix is not Hermitian?
template<typename VTYPE> struct edgi_svd_results_t<complex<VTYPE>, SVD_MAT_GENERAL> {
    complex<VTYPE>* U;
    complex<VTYPE>* S;
    complex<VTYPE>* VT;
    complex<VTYPE>* V;
};

//==========================================================================
// </ugly_code>
//==========================================================================

/** Main solver class */
template<typename MTYPE, svd_mat_t SVD_TYPE> class edgi_plasma_t {

private:

    int Nthreads;
    int nx;
    int ny;

    MTYPE* mat; /**< The matrix to solve. If using test functions, just pass a nullptr and it will be autogenerated. */

    edgi_svd_results_t<MTYPE, SVD_TYPE> results;

    PLASMA_desc** desc;
    time_t start_time;
    time_t end_time;

    void initialize();
    void finalize();
    void gen_rand();

public:
    edgi_plasma_t(int, int, MTYPE*, int);
    ~edgi_plasma_t();

    void svd();
    void sdd();
    void evd();
    void evr(int);
    void svd_test();
    void sdd_test();
    void evd_test();
    void evr_test(int);

    MTYPE* get_U();
    auto get_S();
    MTYPE* get_VT();
    MTYPE* get_V();

    int get_U_dimension(); /**< Returns the length of one side of the U matrix */
    int get_S_dimension(); /**< Length of eigenvalue array */
    int get_V_dimension(); /**< Returns the length of one side of the V matrix */

    MTYPE get_U_max();
    MTYPE get_V_max();

};


template<typename MTYPE, svd_mat_t SVD_TYPE>
edgi_plasma_t<MTYPE, SVD_TYPE>::edgi_plasma_t(int nx_in, int ny_in, MTYPE* mat_in, int Nthreads_in){
    this->Nthreads = Nthreads_in;
    this->nx = nx_in;
    this->ny = ny_in;
    this->mat = mat_in;

    this->results.U = nullptr;
    this->results.S = nullptr;
    this->results.VT = nullptr;
    this->results.V = nullptr;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
edgi_plasma_t<MTYPE, SVD_TYPE>::~edgi_plasma_t(){
    //delete[] this->results.S;
    //delete[] this->results.U;
    //delete[] this->results.VT;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::initialize(){
    this->desc = new PLASMA_desc*;
    *(this->desc) = new PLASMA_desc;

    //omp_set_num_threads(this->Nthreads);
    PLASMA_Init(this->Nthreads);

    time(&(this->start_time));

    return;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::finalize(){

    time(&(this->end_time));
    cout << this->Nthreads << " OpenMP threads -> " << difftime(this->end_time, this->start_time) << " seconds" << endl;

    PLASMA_Dealloc_Handle((void**)this->desc);
    PLASMA_Finalize();

    return;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::svd(){
    cout << "This type is not supported for *svd routines." << endl;
    return;
}
template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::sdd(){
    cout << "This type is not supported for *sdd routines." << endl;
    return;
}
template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::evd(){
    cout << "This type is not supported for *evd routines." << endl;
    return;
}
template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::evr(int Neigs){
    cout << "This type is not supported for *evr routines." << endl;
    return;
}

template<>
void edgi_plasma_t<float, SVD_MAT_GENERAL>::svd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new float[this->nx*this->nx];
    this->results.S = new float[min_xy];
    this->results.VT = new float[this->ny*this->ny];

    PLASMA_Alloc_Workspace_sgesvd(this->nx, this->ny, desc);
    PLASMA_sgesvd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

/*
template<>
void edgi_plasma_t< complex<float>, SVD_MAT_GENERAL >::svd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new complex<float>[this->nx*this->nx];
    this->results.S = new complex<float>[min_xy];
    this->results.VT = new complex<float>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_cgesvd(this->nx, this->ny, desc);
    PLASMA_cgesvd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex32_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,//,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex32_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex32_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}
*/

template<>
void edgi_plasma_t<double, SVD_MAT_GENERAL>::svd(){

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new double[this->nx*this->nx];
    this->results.S = new double[min_xy];
    this->results.VT = new double[this->ny*this->ny];

    PLASMA_Alloc_Workspace_dgesvd(this->nx, this->ny, desc);
    PLASMA_dgesvd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

/*
template<>
void edgi_plasma_t< complex<double>, SVD_MAT_GENERAL >::svd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new complex<double>[this->nx*this->nx];
    this->results.S = new complex<double>[min_xy];
    this->results.VT = new complex<double>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_zgesvd(this->nx, this->ny, desc);
    PLASMA_zgesvd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex64_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,//,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex64_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex64_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}
*/

template<>
void edgi_plasma_t<float, SVD_MAT_SYMMETRIC>::svd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new float[this->nx*this->nx];
    this->results.S = new float[nx];
    this->results.VT = new float[this->ny*this->ny];

    PLASMA_Alloc_Workspace_sgesvd(this->nx, this->ny, desc);
    PLASMA_sgesvd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t<double, SVD_MAT_SYMMETRIC>::svd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new double[this->nx*this->nx];
    this->results.S = new double[nx];
    this->results.VT = new double[this->ny*this->ny];

    PLASMA_Alloc_Workspace_dgesvd(this->nx, this->ny, desc);
    PLASMA_dgesvd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<float>, SVD_MAT_HERMITIAN >::svd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<float>[this->nx*this->nx];
    this->results.S = new float[nx];
    this->results.VT = new complex<float>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_cgesvd(this->nx, this->ny, desc);
    PLASMA_cgesvd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex32_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex32_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex32_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<double>, SVD_MAT_HERMITIAN >::svd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<double>[this->nx*this->nx];
    this->results.S = new double[nx];
    this->results.VT = new complex<double>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_zgesvd(this->nx, this->ny, desc);
    PLASMA_zgesvd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex64_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex64_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex64_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t<float, SVD_MAT_GENERAL>::sdd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new float[this->nx*this->nx];
    this->results.S = new float[min_xy];
    this->results.VT = new float[this->ny*this->ny];

    PLASMA_Alloc_Workspace_sgesdd(this->nx, this->ny, desc);
    PLASMA_sgesdd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

/*
template<>
void edgi_plasma_t< complex<float>, SVD_MAT_GENERAL >::sdd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new complex<float>[this->nx*this->nx];
    this->results.S = new float[min_xy];
    this->results.VT = new complex<float>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_cgesdd(this->nx, this->ny, desc);
    PLASMA_cgesdd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex32_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,//,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex32_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex32_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}
*/

template<>
void edgi_plasma_t<double, SVD_MAT_GENERAL>::sdd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new double[this->nx*this->nx];
    this->results.S = new double[min_xy];
    this->results.VT = new double[this->ny*this->ny];

    PLASMA_Alloc_Workspace_dgesdd(this->nx, this->ny, desc);
    PLASMA_dgesdd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

/*
template<>
void edgi_plasma_t< complex<double>, SVD_MAT_GENERAL >::sdd(){

    this->initialize();

    int min_xy = (this->nx < this->ny) ? this->nx : this->ny;

    this->results.U = new complex<double>[this->nx*this->nx];
    this->results.S = new double[min_xy];
    this->results.VT = new complex<double>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_zgesdd(this->nx, this->ny, desc);
    PLASMA_zgesdd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex64_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,//,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex64_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex64_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}
*/

template<>
void edgi_plasma_t<float, SVD_MAT_SYMMETRIC>::sdd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new float[this->nx*this->nx];
    this->results.S = new float[nx];
    this->results.VT = new float[this->ny*this->ny];

    PLASMA_Alloc_Workspace_sgesdd(this->nx, this->ny, desc);
    PLASMA_sgesdd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t<double, SVD_MAT_SYMMETRIC>::sdd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new double[this->nx*this->nx];
    this->results.S = new double[nx];
    this->results.VT = new double[this->ny*this->ny];

    PLASMA_Alloc_Workspace_dgesdd(this->nx, this->ny, desc);
    PLASMA_dgesdd(PlasmaVec,            // jobu
                  PlasmaVec,            // jobvt
                  this->nx,             // M
                  this->ny,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // S
                  *(this->desc),                // descT
                  this->results.U,    // U
                  this->nx,             // LDU
                  this->results.VT,   // VT
                  this->ny);            // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<float>, SVD_MAT_HERMITIAN >::sdd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<float>[this->nx*this->nx];
    this->results.S = new float[nx];
    this->results.VT = new complex<float>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_cgesdd(this->nx, this->ny, desc);
    PLASMA_cgesdd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex32_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex32_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex32_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<double>, SVD_MAT_HERMITIAN >::sdd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<double>[this->nx*this->nx];
    this->results.S = new double[nx];
    this->results.VT = new complex<double>[this->ny*this->ny];

    PLASMA_Alloc_Workspace_zgesdd(this->nx, this->ny, desc);
    PLASMA_zgesdd(PlasmaVec,                                // jobu
                  PlasmaVec,                                // jobvt
                  this->nx,                                 // M
                  this->ny,                                 // N
                  (PLASMA_Complex64_t*)this->mat,           // A
                  this->nx,                                 // LDA
                  this->results.S,                        // S
                  *(this->desc),                                    // descT
                  (PLASMA_Complex64_t*)this->results.U,   // U
                  this->nx,                                 // LDU
                  (PLASMA_Complex64_t*)this->results.VT,  // VT
                  this->ny);                                // LDVT

    this->finalize();

    return;
}


template<>
void edgi_plasma_t<float, SVD_MAT_SYMMETRIC>::evd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new float[this->nx*this->nx];
    this->results.S = new float[nx];

    PLASMA_Alloc_Workspace_ssyevd(this->nx, this->ny, desc);
    PLASMA_ssyevd(PlasmaVec,            // jobz
                  PlasmaUpper,          // uplo
                  this->nx,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // W
                  *(this->desc),                // descT
                  this->results.U,    // Q
                  this->nx);            // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t<double, SVD_MAT_SYMMETRIC>::evd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new double[this->nx*this->nx];
    this->results.S = new double[nx];

    PLASMA_Alloc_Workspace_dsyevd(this->nx, this->ny, desc);
    PLASMA_dsyevd(PlasmaVec,            // jobz
                  PlasmaUpper,          // uplo
                  this->nx,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  this->results.S,    // W
                  *(this->desc),                // descT
                  this->results.U,    // Q
                  this->nx);            // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<float>, SVD_MAT_HERMITIAN >::evd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<float>[this->nx*this->nx];
    this->results.S = new float[nx];

    PLASMA_Alloc_Workspace_cheevd(this->nx, this->ny, desc);
    PLASMA_cheevd(PlasmaVec,                                // jobz
                  PlasmaUpper,                              // uplo
                  this->nx,                                 // N
                  (PLASMA_Complex32_t*) this->mat,          // A
                  this->nx,                                 // LDA
                  this->results.S,                        // W
                  *(this->desc),                                    // descT
                  (PLASMA_Complex32_t*) this->results.U,  // Q
                  this->nx);                                // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<double>, SVD_MAT_HERMITIAN >::evd(){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<double>[this->nx*this->nx];
    this->results.S = new double[nx];

    PLASMA_Alloc_Workspace_zheevd(this->nx, this->ny, desc);
    PLASMA_zheevd(PlasmaVec,                                // jobz
                  PlasmaUpper,                              // uplo
                  this->nx,                                 // N
                  (PLASMA_Complex64_t*) this->mat,          // A
                  this->nx,                                 // LDA
                  this->results.S,                        // W
                  *(this->desc),                                    // descT
                  (PLASMA_Complex64_t*) this->results.U,  // Q
                  this->nx);                                // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t<float, SVD_MAT_SYMMETRIC>::evr(int Neigs){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new float[this->nx*this->nx];
    this->results.S = new float[nx];

    PLASMA_Alloc_Workspace_ssyevr(this->nx, this->ny, desc);
    PLASMA_ssyevr(PlasmaVec,            // jobz
                  PlasmaAllVec,         // range
                  PlasmaUpper,          // uplo
                  this->nx,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  0, 0, 0, 0,           // vl, vu, il, iu
                  0,                    // abstol
                  &Neigs,               // nbcomputedeig
                  this->results.S,    // W
                  *(this->desc),                // descT
                  this->results.U,    // Q
                  this->nx);            // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t<double, (svd_mat_t)SVD_MAT_SYMMETRIC>::evr(int Neigs){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new double[this->nx*this->nx];
    this->results.S = new double[nx];

    PLASMA_Alloc_Workspace_dsyevr(this->nx, this->ny, desc);
    PLASMA_dsyevr(PlasmaVec,            // jobz
                  PlasmaAllVec,         // range
                  PlasmaUpper,          // uplo
                  this->nx,             // N
                  this->mat,            // A
                  this->nx,             // LDA
                  0, 0, 0, 0,           // vl, vu, il, iu
                  0,                    // abstol
                  &Neigs,               // nbcomputedeig
                  this->results.S,    // W
                  *(this->desc),                // descT
                  this->results.U,    // Q
                  this->nx);            // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<float>, SVD_MAT_HERMITIAN >::evr(int Neigs){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<float>[this->nx*this->nx];
    this->results.S = new float[nx];

    PLASMA_Alloc_Workspace_cheevr(this->nx, this->ny, desc);
    PLASMA_cheevr(PlasmaVec,                                // jobz
                  PlasmaAllVec,                             // range
                  PlasmaUpper,                              // uplo
                  this->nx,                                 // N
                  (PLASMA_Complex32_t*) this->mat,          // A
                  this->nx,                                 // LDA
                  0, 0, 0, 0,                               // vl, vu, il, iu
                  0,                                        // abstol
                  &Neigs,                                   // nbcomputedeig
                  this->results.S,                        // W
                  *(this->desc),                                    // descT
                  (PLASMA_Complex32_t*) this->results.U,  // Q
                  this->nx);                                // LDQ

    this->finalize();

    return;
}

template<>
void edgi_plasma_t< complex<double>, SVD_MAT_HERMITIAN >::evr(int Neigs){

    assert(this->nx == this->ny);

    this->initialize();

    this->results.U = new complex<double>[this->nx*this->nx];
    this->results.S = new double[nx];

    PLASMA_Alloc_Workspace_zheevr(this->nx, this->ny, desc);
    PLASMA_zheevr(PlasmaVec,                                // jobz
                  PlasmaAllVec,                             // range
                  PlasmaUpper,                              // uplo
                  this->nx,                                 // N
                  (PLASMA_Complex64_t*) this->mat,          // A
                  this->nx,                                 // LDA
                  0, 0, 0, 0,                               // vl, vu, il, iu
                  0,                                        // abstol
                  &Neigs,                                   // nbcomputedeig
                  this->results.S,                        // W
                  *(this->desc),                                    // descT
                  (PLASMA_Complex64_t*) this->results.U,  // Q
                  this->nx);                                // LDQ

    this->finalize();

    return;
}


template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::svd_test(){

    if(this->mat){
        // error: mat must be a nullptr to call test routines
    }
    this->mat = new MTYPE[this->nx*this->ny];
    this->gen_rand();
    this->svd();

    return;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::sdd_test(){

    if(this->mat){
        // error: mat must be a nullptr to call test routines
    }
    this->mat = new MTYPE[this->nx*this->ny];
    this->gen_rand();
    this->sdd();

    return;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::evd_test(){

    if(this->mat){
        // error: mat must be a nullptr to call test routines
    }
    this->mat = new MTYPE[this->nx*this->ny];
    this->gen_rand();
    this->evd();

    return;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::evr_test(int Neigs){

    if(this->mat){
        // error: mat must be a nullptr to call test routines
    }
    this->mat = new MTYPE[this->nx*this->ny];
    this->gen_rand();
    this->evr(Neigs);

    return;
}



template<typename MTYPE, svd_mat_t SVD_TYPE>
void edgi_plasma_t<MTYPE, SVD_TYPE>::gen_rand(){
    // error
    return;
}

template<>
void edgi_plasma_t<float, SVD_MAT_GENERAL>::gen_rand(){
    srand(time(NULL));
    int i = 0;
    #pragma omp for
    for(i = 0; i < this->nx*this->ny; i++){
        this->mat[i] = (rand() % 1000) / 100;
    }
    return;
}
template<>
void edgi_plasma_t< complex<float>, SVD_MAT_GENERAL >::gen_rand(){
    srand(time(NULL));
    int i = 0;
    #pragma omp for
    for(i = 0; i < this->nx*this->ny; i++){
        this->mat[i] = complex<float>((rand() % 1000) / 100, (rand() % 1000) / 100);
    }
    return;
}
template<>
void edgi_plasma_t<double, SVD_MAT_GENERAL>::gen_rand(){
    srand(time(NULL));
    int i = 0;
    #pragma omp for
    for(i = 0; i < this->nx*this->ny; i++){
        this->mat[i] = (rand() % 1000) / 100;
    }
    return;
}
template<>
void edgi_plasma_t< complex<double>, SVD_MAT_GENERAL >::gen_rand(){
    srand(time(NULL));
    int i = 0;
    #pragma omp for
    for(i = 0; i < this->nx*this->ny; i++){
        this->mat[i] = complex<double>((rand() % 1000) / 100, (rand() % 1000) / 100);
    }
    return;
}

template<>
void edgi_plasma_t<float, SVD_MAT_SYMMETRIC>::gen_rand(){
    srand(time(NULL));
    int i = 0, j = 0;
    #pragma omp for
    for(i = 0; i < this->nx; i++){
        for(j = i; j < this->ny; j++){
            this->mat[i*this->ny + j] = (rand() % 1000) / 100;
            this->mat[j*this->nx + i] = mat[i*this->ny + j];
        }
    }
    return;
}
template<>
void edgi_plasma_t< complex<float>, SVD_MAT_SYMMETRIC >::gen_rand(){
    srand(time(NULL));
    int i = 0, j = 0;
    #pragma omp for
    for(i = 0; i < this->nx; i++){
        for(j = i; j < this->ny; j++){
            this->mat[i*this->ny + j] = complex<float>((rand() % 1000) / 100, (rand() % 1000) / 100);
            this->mat[j*this->nx + i] = mat[i*this->ny + j];
        }
    }
    return;

}
template<>
void edgi_plasma_t<double, SVD_MAT_SYMMETRIC>::gen_rand(){
    srand(time(NULL));
    int i = 0, j = 0;
    #pragma omp for
    for(i = 0; i < this->nx; i++){
        for(j = i; j < this->ny; j++){
            this->mat[i*this->ny + j] = (rand() % 1000) / 100;
            this->mat[j*this->nx + i] = mat[i*this->ny + j];
        }
    }
    return;
}
template<>
void edgi_plasma_t< complex<double>, SVD_MAT_SYMMETRIC >::gen_rand(){
    srand(time(NULL));
    int i = 0, j = 0;
    #pragma omp for
    for(i = 0; i < this->nx; i++){
        for(j = i; j < this->ny; j++){
            this->mat[i*this->ny + j] = complex<double>((rand() % 1000) / 100, (rand() % 1000) / 100);
            this->mat[j*this->nx + i] = mat[i*this->ny + j];
        }
    }
    return;
}


template<>
void edgi_plasma_t< complex<float>, SVD_MAT_HERMITIAN >::gen_rand(){
    srand(time(NULL));
    int i = 0, j = 0;
    #pragma omp for
    for(i = 0; i < this->nx; i++){
        for(j = i; j < this->ny; j++){
            this->mat[i*this->ny + j] = complex<float>((rand() % 1000) / 100, (rand() % 1000) / 100);
            this->mat[j*this->nx + i] = conj(mat[i*this->ny + j]);
        }
    }
    return;
}
template<>
void edgi_plasma_t< complex<double>, SVD_MAT_HERMITIAN >::gen_rand(){
    srand(time(NULL));
    int i = 0, j = 0;
    #pragma omp for
    for(i = 0; i < this->nx; i++){
        for(j = i; j < this->ny; j++){
            this->mat[i*this->ny + j] = complex<double>((rand() % 1000) / 100, (rand() % 1000) / 100);
            this->mat[j*this->nx + i] = conj(mat[i*this->ny + j]);
        }
    }
    return;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
MTYPE* edgi_plasma_t<MTYPE, SVD_TYPE>::get_U(){
    if(!this->results.U){
        cout << "U does not currently exist." << endl;
        // fatal
    }

    return this->results.U;
}
template<typename MTYPE, svd_mat_t SVD_TYPE>
auto edgi_plasma_t<MTYPE, SVD_TYPE>::get_S(){
    if(!this->results.S){
        cout << "S does not currently exist." << endl;
        // fatal
    }

    return this->results.S;
}
template<typename MTYPE, svd_mat_t SVD_TYPE>
MTYPE* edgi_plasma_t<MTYPE, SVD_TYPE>::get_VT(){
    if(!this->results.VT){
        cout << "VT does not currently exist." << endl;
        // fatal
    }

    return this->results.VT;
}

/** Note: This routine transposes VT in-place; in other words, VT will be V after calling this! */
template<typename MTYPE, svd_mat_t SVD_TYPE>
MTYPE* edgi_plasma_t<MTYPE, SVD_TYPE>::get_V(){
    // fatal
    return;
}
template<>
float* edgi_plasma_t<float, SVD_MAT_GENERAL>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_sgetmi(this->ny,
                      this->ny,
                      this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;
        this->finalize();
    }

    return this->results.V;
}
template<>
float* edgi_plasma_t<float, SVD_MAT_SYMMETRIC>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_sgetmi(this->ny,
                      this->ny,
                      this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;
        this->finalize();
    }

    return this->results.V;
}
template<>
float* edgi_plasma_t<float, SVD_MAT_HERMITIAN>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_sgetmi(this->ny,
                      this->ny,
                      this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;
        this->finalize();
    }

    return this->results.V;
}
template<>
double* edgi_plasma_t<double, SVD_MAT_GENERAL>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_dgetmi(this->ny,
                      this->ny,
                      this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;
    }

    return this->results.V;
}
template<>
double* edgi_plasma_t<double, SVD_MAT_SYMMETRIC>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_dgetmi(this->ny,
                      this->ny,
                      this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;
        this->finalize();
    }

    return this->results.V;
}
template<>
double* edgi_plasma_t<double, SVD_MAT_HERMITIAN>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_dgetmi(this->ny,
                      this->ny,
                      this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;
        this->finalize();
    }

    return this->results.V;
}
template<>
complex<float>* edgi_plasma_t<complex<float>, SVD_MAT_GENERAL>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_cgetmi(this->ny,
                      this->ny,
                      (PLASMA_Complex32_t*)this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;

        for(int i = 0; i < this->ny * this->ny; i++){
            this->results.V[i] = conj(this->results.V[i]);
        }
        this->finalize();
    }

    return this->results.V;
}
template<>
complex<float>* edgi_plasma_t<complex<float>, SVD_MAT_SYMMETRIC>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_cgetmi(this->ny,
                      this->ny,
                      (PLASMA_Complex32_t*)this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;

        for(int i = 0; i < this->ny * this->ny; i++){
            this->results.V[i] = conj(this->results.V[i]);
        }
        this->finalize();
    }

    return this->results.V;
}
template<>
complex<float>* edgi_plasma_t<complex<float>, SVD_MAT_HERMITIAN>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_cgetmi(this->ny,
                      this->ny,
                      (PLASMA_Complex32_t*)this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;

        for(int i = 0; i < this->ny * this->ny; i++){
            this->results.V[i] = conj(this->results.V[i]);
        }
        this->finalize();
    }

    return this->results.V;
}
template<>
complex<double>* edgi_plasma_t<complex<double>, SVD_MAT_GENERAL>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_zgetmi(this->ny,
                      this->ny,
                      (PLASMA_Complex64_t*)this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;

        for(int i = 0; i < this->ny * this->ny; i++){
            this->results.V[i] = conj(this->results.V[i]);
        }
        this->finalize();
    }

    return this->results.V;
}
template<>
complex<double>* edgi_plasma_t<complex<double>, SVD_MAT_SYMMETRIC>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_zgetmi(this->ny,
                      this->ny,
                      (PLASMA_Complex64_t*)this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;

        for(int i = 0; i < this->ny * this->ny; i++){
            this->results.V[i] = conj(this->results.V[i]);
        }
        this->finalize();
    }

    return this->results.V;
}
template<>
complex<double>* edgi_plasma_t<complex<double>, SVD_MAT_HERMITIAN>::get_V(){
    if(this->results.VT){

        this->initialize();
        PLASMA_zgetmi(this->ny,
                      this->ny,
                      (PLASMA_Complex64_t*)this->results.VT,
                      PlasmaCM,
                      this->ny,
                      this->ny);

        this->results.V = this->results.VT;
        this->results.VT = nullptr;

        for(int i = 0; i < this->ny * this->ny; i++){
            this->results.V[i] = conj(this->results.V[i]);
        }
        this->finalize();
    }

    return this->results.V;
}



template<typename MTYPE, svd_mat_t SVD_TYPE>
int edgi_plasma_t<MTYPE, SVD_TYPE>::get_U_dimension(){
    return this->nx;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
int edgi_plasma_t<MTYPE, SVD_TYPE>::get_S_dimension(){
    return (this->nx < this->ny) ? this->nx : this->ny;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
int edgi_plasma_t<MTYPE, SVD_TYPE>::get_V_dimension(){
    return this->ny;
}

template<typename MTYPE, svd_mat_t SVD_TYPE>
MTYPE edgi_plasma_t<MTYPE, SVD_TYPE>::get_U_max(){
    MTYPE max = -1;
    for(int i = 0; i < this->nx * this->nx; i++){
        if(this->results.U[i] > max) max = this->results.U[i];
    }
    return max;
}
template<typename MTYPE, svd_mat_t SVD_TYPE>
MTYPE edgi_plasma_t<MTYPE, SVD_TYPE>::get_V_max(){
    MTYPE max = -1;
    if(this->results.VT){
        for(int i = 0; i < this->ny * this->ny; i++){
            if(this->results.VT[i] > max) max = this->results.VT[i];
        }
    }else{
        for(int i = 0; i < this->ny * this->ny; i++){
            if(this->results.V[i] > max) max = this->results.V[i];
        }
    }
    return max;
}

#endif



