#ifndef EDGI_OPENBLAS_HPP
#define EDGI_OPENBLAS_HPP

#include <cstdlib>
#include <cassert>
#include <ctime>
#include <iostream>
#include <complex>
#include <string>
#include <omp.h>

#include "lapacke.h"
#include "cblas.h"

using std::clock;
using std::complex;
using std::conj;
using std::cout;
using std::endl;
using std::rand;
using std::srand;

typedef enum svd_mat_type {
    SVD_MAT_GENERAL,
    SVD_MAT_SYMMETRIC,
    SVD_MAT_HERMITIAN
} svd_mat_t;


//==========================================================================
// Create solver results struct that can correctly match the results types
// to the kind of matrix we're solving. Ugly code alert!
//==========================================================================


// What types should the results be if the matrix is real-valued?
template<typename VTYPE, svd_mat_t SVD_TYPE> struct edgi_svd_results_t {
    VTYPE* U;
    VTYPE* S;
    VTYPE* VT;
    VTYPE* V;
};

// What types should the results be if the matrix is complex-valued, and the matrix is Hermitian?
template<typename VTYPE> struct edgi_svd_results_t<complex<VTYPE>, SVD_MAT_SYMMETRIC> {
    complex<VTYPE>* U;
    VTYPE* S;
    complex<VTYPE>* VT;
    complex<VTYPE>* V;
};
template<typename VTYPE> struct edgi_svd_results_t<complex<VTYPE>, SVD_MAT_HERMITIAN> {
    complex<VTYPE>* U;
    VTYPE* S;
    complex<VTYPE>* VT;
    complex<VTYPE>* V;
};

// What types should the results be if the matrix is complex-valued, and the matrix is not Hermitian?
template<typename VTYPE> struct edgi_svd_results_t<complex<VTYPE>, SVD_MAT_GENERAL> {
    complex<VTYPE>* U;
    complex<VTYPE>* S;
    complex<VTYPE>* VT;
    complex<VTYPE>* V;
};

//==========================================================================
// </ugly_code>
//==========================================================================

/** Main solver class */
template<typename MTYPE, svd_mat_t SVD_TYPE> class edgi_openblas_t {

private:

    int Nthreads;
    int nx;
    int ny;

    MTYPE* mat; /**< The matrix to solve. If using test functions, just pass a nullptr and it will be autogenerated. */

    edgi_svd_results_t<MTYPE, SVD_TYPE> results;
    int status;

    time_t start_time;
    time_t end_time;

    void initialize();
    void finalize();
    void gen_rand();

public:
    edgi_openblas_t(int, int, MTYPE*, int);
    ~edgi_openblas_t();

    void svd();
    void sdd();
    void evd();
    void evr(int);
    void svd_test();
    void sdd_test();
    void evd_test();
    void evr_test(int);

    MTYPE* get_U();
    auto get_S();
    MTYPE* get_VT();
    MTYPE* get_V();

    int get_U_dimension(); /**< Returns the length of one side of the U matrix */
    int get_S_dimension(); /**< Length of eigenvalue array */
    int get_V_dimension(); /**< Returns the length of one side of the V matrix */

    MTYPE get_U_max();
    MTYPE get_V_max();

};

#include "edgi_openblas.tpp"

#endif
